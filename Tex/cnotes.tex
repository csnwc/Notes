%\documentclass{beamer}
%\usetheme{Ilmenau}

\documentclass[a4,portraitt]{slides}
\usepackage{biggy,graphics,times,epsfig}

\usepackage{hyperref}

%\documentclass[biggy]{slides}

%\documentstyle[graphics,biggy,times,epsfig]{slides}
%\documentstyle[12pt,a4wide,times]{article}


%\setlength{\parindent}{0in}
%\setlength\textheight{\textheight \times 0.5}

\title{Chapter One}

\begin{document}

\begin{center}
{\Large
Programming in C
}

Dr. Neill Campbell

Room 3.14 MVB

Neill.Campbell@bristol.ac.uk\\[1em]
{\small
\verb^http://www.cs.bris.ac.uk/^
}
\end{center}

\section*{About the Course}

{\footnotesize
The course notes were originally based on:\\
{\it
C By Dissection (3rd edition)\\
Al Kelley and Ira Pohl\\
}
because I liked arrays being taught later.
}

\newpage
\subsection*{Resources}
\begin{itemize}
\item Free : \url{https://en.wikibooks.org/wiki/C_Programming}
\item A list of more : \url{https://www.linuxlinks.com/excellent-free-books-learn-c/}
\item Whatever you use, make sure it's {\bf ANSI C} that's being taught, not something else e.g. C11 or C++.
\end{itemize}

\newpage
\subsection*{K\&R}
If you fall in love with C and  know you're going to use it for the rest of your life, the reference `bible' is K\&R 2nd edition.
It's not a textbook for those new to programming, though.
\begin{figure}[h]
\centerline{
\includegraphics[scale=0.65]{../Figs/9780131103627.jpg}
}
\end{figure}

\newpage
\subsection*{Computer Science Ethos}
\begin{itemize}
\item Talk to your friends, ask for help, work together.
\item Never pass off another persons work as your own.
\item Do not pass work to others - either on paper or
electronically.
\item If someone takes your code and submits it, we need to investigate where it originated.
\item Be careful of placing your code on publicly accessible sites e.g. github.
\end{itemize}

\newpage
\subsection*{History of C}
{\samepage
\begin{center}
\begin{figure}[h]
\centerline{
\includegraphics[scale=0.5]{../Figs/evolvec.jpg}
}
\end{figure}
\end{center}
{\small
From {\it Deep C Secrets} by Peter Van Der Linden
}}

\newpage
\subsection*{History of C}
\begin{itemize}
\item BCPL - Martin Richards
\item B - Ken Thomson 1970
\item Both of above are {\em typeless}.
\item C - Dennis Ritchie 1972 designed for\\(\& implemented on) a UNIX system.
\item K\&R C (Kernighan and Ritchie) 1978
\item ANSI C (COMSM1201)
\item C++ - Object Oriented Programming (OOP)
\item Java (Subset of C++, WWW enabled).
\end{itemize}

\subsection*{Why C ?}
\begin{itemize}
\item Low-level (c.f. Java)
\item Doesn't hide nitty-gritty
\item Fast ?
\item Wide acceptability
\item Large parts common to Java
\end{itemize}
\newpage

\newpage
\subsection*{Programming and Software Engineering}
\begin{itemize}
\item Was traditionally Lectured 2(or 3) hours a week for weeks 1-12 
\item With COVID-19 I'll post the equivalent online, broken
into manageable chunks
\item Programming (C), data structures, algorithms - searching, sorting, string processing, trees etc.
\end{itemize}

\newpage
\subsection*{Assessment}
\begin{itemize}
\item Weekly (unmarked) exercises that, if completed, should ensure you are able to pass the unit.
\item Approximately three/four assignments and one lab test.
\item One major project due in early TB2 (35\%).
\item Hard to gauge timings, so don't make any plans in advance -
I'll change it if we're going too fast.
\end{itemize}

\newpage
{\samepage
\subsection*{Help with Computers}
\begin{itemize}
\item Any problems with the computers e.g. installing the correct S/W, accessing lab machines: \url{http://www.bris.ac.uk/it-services/}.
\item They are also the people to see about passwords etc.
\item This page also links to the rather useful Laptop \& Mobile Clinic.
\end{itemize}
}

\newpage
{\samepage
\subsection*{Help with the Unit}
\begin{itemize}
\item Further information is available via the Blackboard site.
\item Help will mainly be via myself giving `live' Q\&A session, the associated MS Teams group and the corresponding Forum.
\item You will often work in a peer group (approx $15$ people).
\item There will be a group of Teaching Assistants to help each of these groups.
\item TAs are not allowed to write pieces of code for you,
nor undertake detailed bug-fixing of your program.
\end{itemize}
}

\newpage
\section*{A First Program}

\begin{verbatim}
/* The traditional first program
   in honour of Dennis Ritchie
   who invented C at Bell Labs
   in 1972 */

#include <stdio.h>

int main(void)
{
   printf("Hello, world!\n");
   return 0;
}
\end{verbatim}

\newpage
\section*{Dissecting the 1st Program (1)}

\begin{itemize}
\item Comments are bracketed by the {\bf /*} and {\bf */} pair.
\item
\begin{verbatim}
#include <stdio.h>
\end{verbatim}
Lines that begin with a {\bf \#}
are called preprocessing directives.
\item \begin{verbatim}
int main(void)
\end{verbatim}
Every program has a function called \begin{verbatim}
main()
\end{verbatim}

\item Statements are grouped using braces,
\begin{verbatim}
{ ... }
\end{verbatim}
\end{itemize}

\section*{Dissecting the 1st Program (2)}

\begin{itemize}
\item \verb+printf()+ One of the pre-defined library functions being called (invoked) using a single argument the string:
\begin{verbatim}
"Hello, world!\n"
\end{verbatim}
\item The \verb+\n+ means print the single character {\it newline}.
\item Notice all declarations and statements are terminated with a
semi-colon.
\item \verb+return(0)+
Instruct the Operating System that the function
\verb+main()+ has completed successfully.
\end{itemize}

\newpage
\newpage
\section*{The Second Program}

\begin{verbatim}
#include <stdio.h>

int main(void)
{
   int   inches, feet, fathoms;

   fathoms = 7;
   feet = 6 * fathoms;
   inches = 12 * feet;

   printf("Wreck of the Hesperus:\n");
   printf("Its depth at sea in");
   printf(" different units:\n");
   printf("   %d fathoms\n", fathoms);
   printf("   %d feet\n", feet);
   printf("   %d inches\n", inches);
   return 0;
}
\end{verbatim}

\section*{Dissecting the 2nd Program}

\begin{itemize}
\item \verb+#include <stdio.h>+ Always required when using I/O.
\item \verb+int inches, feet, fathoms;+ {\it Declaration}
\item \verb+fathoms = 7;+ {\it  Assignment }
\item \verb+printf()+has 2 Arguments.
The {\it control string}
contains a \verb+%d+ to indicate an integer is to be\\ printed.
\end{itemize}

\begin{verbatim}
preprocessing directives

int main(void)
{
   declarations

   statements
}
\end{verbatim}
\newpage
\section*{ Arithmetic Operators }

\begin{itemize}
\item \verb^+ , - , / , *, %^
\item Addition, Subtraction, Division, Multiplication,\\ Modulus.
\item Integer arithmetic discards remainer i.e.\\
\verb+1/2+ is 0 , \verb+7/2+ is 3.
\item Modulus (Remainder) Arithmetic.\\
\verb+7%4+ is 3, \verb+12%6+ is 0.

\item
Only available for integer arithmetic.
\end{itemize}

\newpage
\section*{ The Character Type }

\begin{itemize}
\item The  keyword \verb+char+ stands for character.

\item Used with single quotes i.e.
\verb^'A'^,
\verb^'+'^.

\end{itemize}

\begin{verbatim}
#include <stdio.h>

int main(void)
{
   char   c;

   c = 'A';
   printf("%c\n", c);
   return 0;
}
\end{verbatim}

\begin{itemize}
\item The letter A is printed.
\item Note the \verb+%c+ conversion format.
\end{itemize}

\newpage
\section*{ Floating Types }


\begin{itemize}
\item In ANSI C there are three floating types:
    \begin{enumerate}
        \item \verb+float+
        \item \verb+double+
        \item \verb+long double+
    \end{enumerate}
\item The {\it Working Type} is doubles.
\end{itemize}

\begin{small}
\begin{verbatim}
#include <stdio.h>

int main(void)
{
   float   x, y;

   x = 1.0;
   y = 2.0;
   printf("Sum of x & y is %f.\n", x + y);
   return 0;
}
\end{verbatim}
\end{small}

\section*{The Preprocessor}

\begin{itemize}
\item A \verb+#+ in the first column signifies
a preprocessor statement.

\item \verb+#include <file.h>+
Exchange this line for
the entire contents of \verb+file.h+,
which is to be found in a standard place.

\item \verb+#define ROUGH_PI (22.0/7.0)+
\\  Replace all occurrences of \verb+ROUGH_PI+
with\\ \verb+ (22.0/7.0)+.

\item
Include files generally contain other \verb+#define+'s
and \verb+#include+'s.

\end{itemize}

\newpage
\section*{Using printf()}

\begin{itemize}
\item \verb+printf( fmt-str, arg1, arg2, ...);+

\end{itemize}

\begin{center}
\begin{tabular}{|c|l|} \hline
\verb+%c+   & Characters \\ \hline
 \verb+%d+  & Integers \\ \hline
 \verb+%e+  & Floats/Doubles (Engineering Notation) \\ \hline
 \verb+%f+  & Floats/Doubles \\ \hline
 \verb+%s+  & Strings \\ \hline
\end{tabular}
\end{center}

\begin{itemize}
\item Fixed-width fields: \verb+printf("F:%7f\n", f);+ \\
\verb+F: 3.0001+

\item Fixed Precision: \verb+printf("F:%.2f\n", f);+\\
\verb+F:3.00+
\end{itemize}

\newpage
\section*{Using scanf()}

\begin{itemize}
\item Similar to \verb+printf()+ but deals with
{\it input} rather than {\it output}.

\item \verb+scanf(fmt-str, &arg1, &arg2, ...);+

\item Note that the {\it address} of the argument is required.

\end{itemize}

\begin{center}
\begin{tabular}{|c|l|} \hline
\verb+%c+   & Characters \\ \hline
\verb+%d+   & Integers \\ \hline
\verb+%f+   & Floats \\ \hline
\verb+%lf+  & Doubles \\ \hline
\verb+%s+   & Strings \\ \hline
\end{tabular}
\end{center}

\begin{itemize}
\item Note doubles handled differently than floats.

\end{itemize}

\newpage
\section*{ The {\tt while} Loop }

\begin{small}
{\bf
\begin{verbatim}
while (test is true) {
    statement 1;
        ...
    statement n;
}
\end{verbatim}
}

\begin{verbatim}
/* Sums are computed. */
#include <stdio.h>

int main(void)
{
   int     cnt = 0;
   float   sum = 0.0, x;

   printf("Input some numbers:  ");
   while (scanf("%f", &x) == 1) {
      cnt = cnt + 1;
      sum = sum + x;
   }
   printf("\n%s%5d\n%s%12f\n\n",
      "Count:", cnt,
      "  Sum:", sum);
   return 0;
}
\end{verbatim}
\end{small}

\newpage
\section*{Common Mistakes}

\subsubsection*{Missing "}
\begin{verbatim}
printf("%c\n, ch);
\end{verbatim}

\subsubsection*{Missing ;}
\begin{verbatim}
a = a + 1
\end{verbatim}

\subsubsection*{Missing Address in {\tt scanf()}}
\begin{verbatim}
scanf("%d", a);
\end{verbatim}

\newpage
\begin{center}
{\Large Chapter Two \\ Operators}
\end{center}

\section*{Grammar}


\begin{itemize}
\item  C has a grammar/syntax like every other language.
\item  It has {\it Keywords}, {\it Identifiers}, {\it Constants}, {\it String Constants}, {\it Operators} and {\it Punctuators}.
\item
Valid Identifiers :\\
\verb^k^,
\verb^_id^,
\verb^iamanidentifier2^,
\verb^so_am_i^.
\item  {\bf Invalid} Identifiers :\\
\verb^not#me^,
\verb^101_south^,
\verb^-plus^.
\item  Constants :\\
\verb^17^ (decimal),
\verb^017^ (octal),
\verb^0x17^ (hexadecimal).
\item  String Constant enclosed in double-quotes:\\
\verb^"I am a string"^
\end{itemize}

\section*{Operators}

\begin{itemize}
\item All operators have rules of both {\it precedence}
and {\it associativity}.
\item  \verb^1 + 2 * 3^ is the same as
\verb^1 + (2 * 3)^ because \verb^*^ has
a higher precedence than \verb^+^.
\item  The associativity of \verb^+^ is left-to-right, thus\\
\verb^1 + 2 + 3^ is equivalent to
\verb^(1 + 2) + 3^.
\item  Increment and decrement operators:\\
\verb^i++;^ is equivalent to \verb^i = i + 1;^
\item  May also be prefixed \verb^--i;^
\end{itemize}
\begin{verbatim}
int a, b, c = 0;
a = ++c;
b = c++;
printf("%d %d %d\n", a, b, ++c);
\end{verbatim}

\section*{Assignment}

\begin{itemize}
\item  The \verb^=^ operator has a low precedence
and a right-to-left associativity.
\item  \verb^a = b = c = 0; ^ is valid and equivalent to:\\
\verb^a = (b = (c = 0));^
\item  \verb^i = i + 3;^ is the same as \verb^i += 3;^
\item  Many other operators are possible e.g.\\\\ \verb^-=, *=, /=^.
\end{itemize}

\newpage
\section*{The Power of 2 Program}



\begin{verbatim}
/* Some powers of 2 are printed. */

#include <stdio.h>

int main(void)
{
   int   i = 0, power = 1;

   while (++i <= 10)
      printf("%5d", power *= 2);
   printf("\n");
   return 0;
}
\end{verbatim}

The output is:

{\tiny
\begin{verbatim}
    2    4    8   16   32   64  128  256  512 1024
\end{verbatim}
}

\newpage
\section*{Random Numbers}

\begin{verbatim}
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
   int   i, n;

   printf("\n%s\n%s",
    "Randomly distributed integers"
    "are printed." ,
    "How many do you want to see?  ");
   scanf("%d", &n);
   for (i = 0; i < n; ++i) {
      if (i % 4 == 0)
         printf("\n");
      printf("%12d", rand());
   }
   printf("\n");
   return 0;
}
\end{verbatim}

\section*{The Standard Library}


The output is:

{\tiny
\begin{verbatim}
Some randomly distributed integers will be printed.
How many do you want to see?  11

    16838     5758    10113    17515    31051     5627
    23010     7419    16212     4086     2749
\end{verbatim}
}

\begin{itemize}
\item Definitions required for the proper use of
many functions such as\\ \verb^rand()^
are found in \verb^stdlib.h^.
\item  Do not mistake these header files for the libraries
themselves !
\end{itemize}

\newpage
\begin{center}
{\Large Chapter Three \\ Flow Control}
\end{center}

\section*{Relations}

\begin{center}
\begin{tabular}{|l|l|} \hline
\verb^<^    & less than             \\ \hline
\verb^>^    & greater than          \\ \hline
\verb^<=^   & less than or equal to     \\ \hline
\verb^>=^   & greater than or equal to  \\ \hline
\verb^==^   & {\bf equal to}        \\ \hline
\verb^!=^   & not equal to          \\ \hline
\verb^!^    & not               \\ \hline
\verb^&&^   & logical and           \\ \hline
\verb^||^   & logical or            \\ \hline
\end{tabular}
\end{center}

\newpage
\section*{True and False}

\begin{itemize}
\item Any relation is either {\it true} or {\it false}.
\item Any non-zero value is {\it true}.
\item \verb^(a < b)^ returns the value {\it 0} or {\it 1}.
\item \verb^(i == 5)^ is a {\bf test} not an {\bf assignment}.
\item \verb^(!a)^ is either {\it true (1)} or {\it false (0)}.
\item \verb^(a && b)^ is {\it true} if both \verb^a^ and \verb^b^ are {\it true}.
\end{itemize}

\newpage
\section*{Short-Circuit Evaluation}

\begin{verbatim}
if(x >= 0.0 && sqrt(x) < 10.0){

..... /* Do Something */

}
\end{verbatim}

The \verb^sqrt()^ statement is never reached if the first test is {\it false},
since in a logical AND, once any expression is {\it false} the whole must
be {\it false}.


\newpage
\section*{The {\tt if()} Statement}

\begin{verbatim}
if (expr)
   statement
\end{verbatim}

If more than one statement is required:

\begin{verbatim}
if (expr) {
   statement-1
       .
       .
       .
   statement-n
}
\end{verbatim}

\newpage
Adding an \verb^else^ statement:

\begin{verbatim}
if (expr) {
   statement-1
       .
       .
       .
   statement-n
}
else{
   statement-a
       .
       .
       .
   statement-e
}
\end{verbatim}

\newpage
A practical example:

\begin{verbatim}
#include <stdio.h>

int main(void)
{
   int   x, y, z, min;

   printf("Input three integers:  ");
   scanf("%d%d%d", &x, &y, &z);
   if (x < y)
      min = x;
   else
      min = y;
   if (z < min)
      min = z;
   printf("The minimum value is " \
          "%d\n", min);
   return 0;
}
\end{verbatim}

\section*{The {\tt while()} Statement}

\begin{verbatim}
while(expr)
   statement
\end{verbatim}

This, as with the \verb^for^ loop, may execute compound statements:

\begin{verbatim}
while(expr){
   statement-1
       .
       .
       .
   statement-n
}
\end{verbatim}

\section*{The {\tt for()} Loop}

This is one of the more complex and heavily used means
for controlling execution flow.

\begin{verbatim}
for( init ; test; loop){
   statement-1
       .
       .
       .
   statement-n
}
\end{verbatim}

\newpage
and may be thought of as:
\begin{verbatim}
init;
while(test){
   statement-1
       .
       .
       .
   statement-n
   loop;
}
\end{verbatim}

In the \verb^for()^ loop, note:
\begin{itemize}
\item Semi-colons separate the three parts.
\item Any (or all) of the three parts could be empty.
\item If the test part is empty, it evaluates to {\it true}.\\
\verb^for(;;){ a+=1; }^  is an infinite loop.
\end{itemize}

\newpage
{\samepage
\begin{verbatim}
/* Find triples of integers that
   add up to N.                  */

#include <stdio.h>

#define   N   7

int main(void)
{
   int   cnt = 0, i, j, k;

   for (i = 0; i <= N; i++)
      for (j = 0; j <= N; j++)
       for (k = 0; k <= N; k++)
          if (i + j + k == N) {
             ++cnt;
             printf("%3d%3d%3d\n",
                    i, j, k);
          }
   printf("\nCount: %d\n", cnt);
   return 0;
}
\end{verbatim}
}
\newpage
The result is:

{\tiny
\begin{verbatim}
  0  0  7
  0  1  6
  0  2  5
  0  3  4
  0  4  3
  0  5  2
  0  6  1
  0  7  0
  1  0  6
  1  1  5
  1  2  4
  1  3  3
  1  4  2
  1  5  1
  1  6  0
  2  0  5
  2  1  4
  2  2  3
  2  3  2
  2  4  1
  2  5  0
  3  0  4
  3  1  3
  3  2  2
  3  3  1
  3  4  0
  4  0  3
  4  1  2
  4  2  1
  4  3  0
  5  0  2
  5  1  1
  5  2  0
  6  0  1
  6  1  0
  7  0  0
\end{verbatim}
}

\section*{The Comma Operator}

This has the lowest predence of all the operators in C
and associates left to right.

\begin{verbatim}
a = 0 , b = 1;
\end{verbatim}

Hence, the \verb^for^ loop may become quite complex :

\begin{verbatim}
for(sum = 0 , i = 1; i <= n; ++i)
   sum += i;
\end{verbatim}

An equivalent, but more difficult to read expression :

{\small
\begin{verbatim}
for(sum = 0 , i = 1; i <= n; ++i, sum += i);
\end{verbatim}
}

\begin{itemize}
\item Notice the loop has an empty body, hence the semicolon.
\end{itemize}

\newpage
\section*{The {\tt do-while()} Statement}

\begin{verbatim}
do {
   statement-1
       .
       .
       .
   statement-n
} while ( test );
\end{verbatim}

Unlike the \verb^while()^ loop, the \verb^do-while()^ will always
be executed at least once.

\newpage
\section*{The {\tt switch()} Statement}

\begin{verbatim}
switch (val) {
   case 1 :
      a++;
      break;
   case 2 :
   case 3 :
      b++;
      break;
   default :
      c++;
}
\end{verbatim}

\begin{itemize}
\item The \verb^val^ must be an integer.
\item The \verb^break^ statement causes execution to jump out
of the loop. No \verb^break^ statement causes execution to
`fall through' to the next line.
\item The \verb^default^ label is a catch-all.
\end{itemize}

\newpage
\section*{The Conditional Operator}

\begin{verbatim}
expr1 ? expr2 : expr3
\end{verbatim}

If \verb^expr1^ is {\it true} then \verb^expr2^ is executed, else
\verb^expr3^ is evaluated, i.e.:

\verb^x = ((y < z) ? y : z);^

\newpage
\begin{center}
{\Large Chapter Four \\ Functions}
\end{center}

\begin{verbatim}
#include <stdio.h>

int   min(int a, int b);

int main(void)
{
   int   j, k, m;

   printf("Input two integers:  ");
   scanf("%d%d", &j, &k);
   m = min(j, k);
   printf("\nOf the two values " \
          " %d and %d, " \
          "the minimum is %d.\n\n",
          j, k, m);
   return 0;
}
\end{verbatim}

\newpage

\begin{verbatim}
int min(int a, int b)
{
   if (a < b)
      return a;
   else
      return b;
}
\end{verbatim}

\begin{itemize}
\item Execution begins, as normal, in the \verb^main()^ function.
\item The function {\it prototype is shown} at the top of the file.
This allows the compiler to check the code more thoroughly.
\item The function \verb^min()^ returns an \verb^int^ and takes
two \verb^int^'s as arguments.
\item The function is defined between two braces.
\item The \verb^return^ statement is used return a value
to the calling statement.
\item A function which has no return value, is declared \verb^void^
and is equivalent to a procedure.
\end{itemize}

\section*{Assert}

The assert macro is defined in the header file\\ \verb^assert.h^.
This is used to ensure the value of an expression is as we
expect it to be.

\newpage
\begin{verbatim}
#include <assert.h>

double f(int a, int b)
{

   double x;

   assert(a > 0);

   /* precondition */
   assert(b >= 7 && b <= 11);

      .
      .
      .

   /* postcondition */
   assert(x >= 1.0);

   return(x);
}
\end{verbatim}

\begin{itemize}
\item If an assertion fails, an error is printed and the
program is aborted.
\item By \verb^#define^'ing \verb^NDEBUG^ all assertions are
ignored, allowing them to be used during development and switched
off later.
\end{itemize}

\newpage
\section*{Program Layout}
{\samepage
It is common for the \verb^main()^ function to come
first in a program :
\begin{verbatim}
#include <stdio.h>
#include <stdlib.h>

list of function prototypes

int main(void)
{
   . . . . .
}

int f1(int a, int b)
{
   . . . . .
}

int f2(int a, int b)
{
   . . . . .
}
\end{verbatim}
}

\newpage
However, it is possible to avoid the need for function prototypes
by defining a function before it is used :

\begin{verbatim}
#include <stdio.h>
#include <stdlib.h>

int f1(int a, int b)
{
   . . . . .
}

int f2(int a, int b)
{
   . . . . .
}

int main(void)
{

   . . . . .

}
\end{verbatim}

\newpage
\section*{Call by Value}

In the following example, a function is passed an integer
using call by value:

\begin{verbatim}
#include <stdio.h>

void fnc1(int a);

int main(void)
{

   int x = 1;

   fnc1(x);
   printf("%d\n", x);

}
\end{verbatim}
\newpage
\begin{verbatim}
void fnc1(int a)
{

   a = a + 1;

}
\end{verbatim}

The function does not change the value of \verb^x^ in\\
\verb^main()^, since \verb^a^ in the function is effectively
only a {\bf copy} of the variable.

\newpage
\section*{Multiply}
Write a simple function \verb^int mul(int a, int b)^ which
multiples two integers together {\b without} the use of the
multiply symbol in C (i.e. the \verb^*^).

Use \verb^assert()^ calls in \verb^main()^ test it thoroughly.

\newpage
\section*{Recursion}

{\samepage
A repeated computation computation is normally
achieved via {\it iteration}, e.g. using \verb^for()^:

\begin{verbatim}
#include <stdio.h>

int fact(int a);

int main(void)
{

   int a, f;

   printf("Input a number :\n");
   scanf("%d", &a);
   f = fact(a);
   printf("%d! is %d\n", a, f);

   return(0);

}
\end{verbatim}
}
\newpage
\begin{verbatim}
int fact(int a)
{

   int i;
   int tot = 1;

   for(i=1; i<=a; i++){
      tot *= i;
   }
   return tot;
}
\end{verbatim}

We could also achieve this via {\it recursion} :

\newpage
{\samepage
\begin{verbatim}
#include <stdio.h>

int fact(int a);

int main(void)
{

   int a, f;

   printf("Input a number :\n");
   scanf("%d", &a);
   f = fact(a);
   printf("%d! is %d\n", a, f);

   return(0);
}

int fact(int a)
{
   if(a > 0)
      return (a*fact(a - 1));
   else
      return 1;

}
\end{verbatim}
}
\newpage
\begin{center}
{\Large Chapter Five \\ Characters}
\end{center}

\section*{Storage of Characters}

\begin{itemize}
\item Characters are stored in the machine as one byte i.e.\ one
of {\bf 256} possible values.
\item These may be thought of a characters, or very small integers.
\item Only a subset of these 256 values are required
for the printable characters, space, newline etc.
\end{itemize}

\newpage
\begin{itemize}
\item Declaration:
\begin{verbatim}
char c;

c = 'A';
\end{verbatim}
or :
\begin{verbatim}
char c1 = 'A', c2 = '*', c3 = ';' ;
\end{verbatim}

The particular integer used to represent a character
is dependent on the encoding used. The most common
of these, used on most UNIX and PC platforms, is ASCII.

\begin{center}
\begin{tabular}{|l|lllll|}\hline
lowercase   & 'a' & 'b' & 'c' & \verb^...^ & 'z' \\
ASCII value & 97  &  98 &  99 & \verb^...^ & 112 \\ \hline
uppercase   & 'A' & 'B' & 'C' & \verb^...^ & 'Z' \\
ASCII value & 65  &  66 &  67 & \verb^...^ &  90 \\ \hline
digit       & '0' & '1' & '2' & \verb^...^ & '9' \\
ASCII value & 48  &  49 &  50 & \verb^...^ &  57 \\ \hline
other       & '\&' & '*' & '+' & \verb^...^ & \\
ASCII value & 38  &  42 &  43 & \verb^...^ & \\ \hline
\end{tabular}
\end{center}

\item When using \verb^printf()^ and \verb^scanf()^ the formats
\verb^%c^ and \verb^%d^ do very different things :
\begin{verbatim}
char c = 'a'
printf("%c\n", c); /* prints : a  */
printf("%d\n", c); /* prints : 97 */
\end{verbatim}

\item Hard-to-print characters have an escape\\ sequence
i.e. to print a newline, the 2 character escape \verb^'\n'^ is used.
\end{itemize}

\newpage
\section*{Using {\tt getchar()} and {\tt putchar()}}

\begin{verbatim}
/* Outputs characters twice */                                                     
#include <stdio.h>

int main(void)
{

   char c;
   while (1) {
      c = getchar();
      putchar(c);
      putchar(c);
   }
   return 0;
}
\end{verbatim}
\newpage

This has the unfortunate problem of never terminating,
a {\tt CTRL-C} would be required.

\begin{verbatim}
#include <stdio.h>

int main(void)
{
   int   c;

   while ((c = getchar()) != EOF) {
      putchar(c);
      putchar(c);
   }
   return 0;
}
\end{verbatim}

The end-of-file constant is defined in {\tt stdio.h}. Although
system dependent, {\tt -1} is often used. On the UNIX system
this is generated when the end of a file being piped is reached,
or when {\tt CTRL-D} is pressed.

\section*{Capitalising}

\begin{verbatim}
/* Outputs characters twice */

#include <stdio.h>

#define CAPS ('A' - 'a')

int main(void)
{
   int   c;

   while ((c = getchar()) != EOF)
      if (c >= 'a' && c <= 'z')
          putchar(c + CAPS);
      else
         putchar(c);
   return 0;
}
\end{verbatim}

\newpage
This is more easily achieved by using some of
the definitions found in {\tt ctype.h}.

\begin{center}
\begin{tabular}{|l|l|} \hline
Macro        & {\tt true} returned if: \\ \hline
isalnum(int c) & Letter or digit \\
isalpha(int c) & Letter \\
iscntrl(int c) & Control character \\
isdigit(int c) & Digit \\
isgraph(int c) & Printable (not space) \\
islower(int c) & Lowercase\\
isprint(int c) & Printable\\
ispunct(int c) & Punctuation\\
isspace(int c) & White Space\\
isupper(int c) & Uppercase\\
isxdigit(int c)& Hexadecimal\\
isascii(int c) & ASCII code \\ \hline
\end{tabular}
\end{center}


Some useful functions are :

\begin{center}
\begin{tabular}{|l|l|} \hline
Function/Macro & Returns: \\ \hline
int tolower(int c) & Lowercase c \\
int toupper(int c) & Uppercase c \\
int toascii(int c) & ASCII code for c \\ \hline
\end{tabular}
\end{center}

\newpage
A better version of capitalise is now :

\begin{verbatim}
#include <stdio.h>
#include <ctype.h>

int main(void)
{
   int   c;

   while ((c = getchar()) != EOF)
      if (islower(c))
         putchar(toupper(c));
      else
         putchar(c);
   return 0;
}
\end{verbatim}

\newpage
\begin{center}
{\Large Chapter Six \\ Data Types}
\end{center}

\section*{Fundamental Data types}

{\bf [}unsigned $|$ signed{\bf ]\ \ [}long $|$ short{\bf ]\ \ [}int $|$ float $|$ double{\bf ]}

{\small
\begin{center}
\begin{tabular}{|lll|} \hline
char            & signed char       & unsigned char \\
signed short int    & signed int        & signed long int \\
unsigned short int  & unsigned int      & unsigned long int \\
float           & double        & long double \\
\hline
\end{tabular}
\end{center}
}

The use of {\tt int} implies {\tt signed int} without the need
to state it. Likewise {\tt unsigned short} means\\ {\tt unsigned short
int}.

\section*{Binary Storage of Numbers}

In an unsigned char :

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|}\hline
$2^7$ & $2^6$ & $2^5$ & $2^4$ & $2^3$ & $2^2$ & $2^1$ & $2^0$ \\ \hline
0     & 1     & 0     & 0     & 1     & 1     & 0     & 0     \\ \hline
\end{tabular}
\end{center}

The above represents : $1 * 64 + 1 * 8 + 1 * 4 = 76$.

{\small
\begin{center}
\begin{tabular}{|l|l|l|l|} \hline
Type        & Num Bytes & Minimum   & Maximum   \\ \hline
signed char & 1     & -128      & 127       \\
unsigned char   & 1     & 0     & 255       \\
signed short    & 2 (Often) & -32768    & 32767 \\
unsigned short  & 2 (Often) & 0     & 65535 \\
signed int  & 4 (Often) & -2147483648   & 2147483647    \\
unsigned int    & 4 (Often) & 0     & 4294967295    \\
signed float    & 4 (Often) & $10^{-38}$    & $10^{+38}$    \\
\hline
\end{tabular}
\end{center}
}

\begin{itemize}
\item Not all floats are representable so are only approximated.
\item Floating operations need not be exact.
\end{itemize}

To find the exact size in bytes of a type on a particular machine,
use {\tt sizeof(type)}. On a Dell Windows 10 laptop running WSL:
{\small
\begin{verbatim}
#include <stdio.h>

int main(void)
{
   printf("\n");
   printf("char\t\t:%3ld\n", sizeof(char));
   printf("short\t\t:%3ld\n", sizeof(short));
   printf("int\t\t:%3ld\n", sizeof(int));
   printf("long\t\t:%3ld\n", sizeof(long));
   printf("unsigned\t:%3ld\n", sizeof(unsigned));
   printf("float\t\t:%3ld\n", sizeof(float));
   printf("dbl\t\t:%3ld\n", sizeof(double));
   printf("long dbl\t:%3ld\n", sizeof(long double));
   printf("\n");

   return 0;

}
\end{verbatim}
}

results in :
{\small
\begin{verbatim}
char            :  1
short           :  2
int             :  4
long            :  8
unsigned        :  4
float           :  4
dbl             :  8
long dbl        : 16
\end{verbatim}
}

\newpage
\section*{Mathematical Functions}

There are no mathematical functions built into the C language.
However, there are many functions in the maths library
which may linked in using the \textbf{-lm} option with the compiler.

Functions include :
\begin{verbatim}
sqrt()  pow()  exp()  log()
 sin()  cos()  tan()
\end{verbatim}
Most take {\tt double}'s as arguments and\\ return {\tt double}'s.
A demonstration of one of the functions is shown :
\newpage
\begin{verbatim}
/* Precision Demo */
#include <stdio.h>
#include <math.h>

int main(void)
{

   int i;
   double x, y;

   printf("Enter a Number : ");
   scanf("%lf", &x);
   y = x;
   for(i=0; i< 100000; i++){
      y = pow(y, 80.0);
      y = pow(y, 1.0/80.0);
   }
   printf("%.10f %.10f\n", x, y);
   return 0;

}
\end{verbatim}
{\tt
Enter a Number : 1234.5678\\
1234.5678000000 1234.5678000{\bf 455}
}

\section*{Casting}

An explicit type conversion is called a {\it cast}.
For instance if we need to find the cube of an integer~\verb^i^:\\
\verb^k = (int) pow( (double) i , 3.0);^

\newpage
\begin{center}
{\Large Chapter Seven \\ Enumeration \& Typedefs}
\end{center}

\section*{Enumerated Types}

{\small
\begin{verbatim}
enum day { sun, mon, tue, wed, thu, fri, sat};
\end{verbatim}
}

\begin{itemize}
\item This creates a user-defined {\bf type} \verb^enum day^.
\item The enumerators are constants of type \verb^int^.
\item By default the first (\verb^sun^) has the value \verb^0^,
the second has the value \verb^1^ and so on.
\item An example of their use:
\begin{verbatim}
enum day d1;
 . . .
d1 = fri;
\end{verbatim}
\item The default numbering may be changed as well:
{\small
\begin{verbatim}
enum fruit{apple=7, pear, orange=3, lemon};
\end{verbatim}
}
\item Use enumerated types as constants to aid readability -
they are self-documenting.
\item Declare them in a header (\verb^.h^) file.
\item Note that the type is \verb^enum day^; the
keyword \verb^enum^ is not enough.
\end{itemize}

\newpage
\section*{Typedefs}
\begin{itemize}
\item Sometimes it is useful to associate a particular name with
a certain type, e.g.:
\begin{verbatim}
typedef int colour;
\end{verbatim}
\item Now the type \verb^colour^ is synonymous with the type \verb^int^.
\item Makes code self-documenting.
\item Helps to control complexity when programmers are building
complicated or lengthy user-defined types (See {\bf structures} Chapter 12).
\end{itemize}

\newpage
{\samepage
\section*{Combining {\tt typedef}s and {\tt enum}s}
\begin{itemize}
\item Often \verb^typedef^'s are used in conjunction with enumerated types:
{\small
\begin{verbatim}
enum day {sun,mon,tue,wed,thu,fri,sat};

typedef    enum day     day;

day find_next_day(day d)
{

   day next_day;

   switch(d){
      case sun:
         next_day = mon;
         break;
      case mon:
         next_day = tue;
         break;
      . . . .
      case sat:
         next_day = sun;
         break;
      default:
         printf("I wasn't expecting " \
                "that !\n");
   }
   return next_day;
}
\end{verbatim}
}
\end{itemize}
}
\newpage
\section{Style}

\begin{verbatim}
enum veg {beet, carrot, pea};
typedef enum veg veg;
veg v1, v2;
v1 = carrot;
\end{verbatim}
\begin{itemize}
\item We can combine the two operations into one:
{\small
\begin{verbatim}
typedef enum veg {beet,carrot,pea} veg;
veg v1, v2;
v1 = carrot;
\end{verbatim}
}
\item Assigning:
\begin{verbatim}
v1 = 10;
\end{verbatim}
is very poor programming style !
\end{itemize}

\newpage
\section{Fever}
Rewrite/complete this code using \verb^typedefs^ and \verb^enum^s to
create self-documenting code in any manner you wish.
{\small
\begin{verbatim}
#include <stdio.h>
#include <assert.h>

int fvr(double t, int s);

int main(void)
{
   assert(fvr(37.5, 0)==1);
   assert(fvr(36.5, 0)==0);
   assert(fvr(96.5, 1)==0);
   assert(fvr(99.5, 1)==1);

   return 0;
}

/* Argument 1 is temperature
   Argument 2 is scale (0=>Celsius, 1=>Farenheit)
*/
int fvr(double t, int s)
{
}
\end{verbatim}
}



\newpage
\begin{center}
{\Large Chapter Eight\\ Pointers}
\end{center}

\section*{Call-by-Value}

\begin{verbatim}
#include <stdio.h>

void change(int i);

int main(void)
{
   int v = 1;
   change(v);
   printf("%d\n", v);
}

void change(int v)
{
   v = 2;
}
\end{verbatim}

\newpage
In the program, the function cannot change
the value of \verb^v^ as defined in \verb^main()^ since
a {\bf copy} is made of it.

To allow a function to modify the value of a variable
passed to it we need a mechanism known as
{\bf call-by-reference}, which uses the {\bf address}
of variables (pointers).


\newpage
\section*{Pointers}

We have already seen addresses used with \verb^scanf()^.
The function call:
\begin{verbatim}
scanf("%d", &v);
\end{verbatim}
causes the appropriate value to be stored at a particular
address in memory.
If \verb^v^ is  a variable, then \verb^&v^ is its
address, or location, in memory.

{\samepage
\section*{Declaring Pointers}
\begin{verbatim}
int i, *p;
\end{verbatim}
Here \verb^i^ is an \verb^int^ and \verb^p^ is of type
{\it pointer to int}. Pointers have a legal range which
includes the special address \verb^0^ and a set of positive
integers which are the machine addresses of a particular
system.
}

\newpage
{\samepage
\begin{center}
\begin{figure}[h]
\centerline{
\includegraphics{../Figs/point8_1.eps}
}
\end{figure}
\end{center}
\vspace{-1in}
\section*{Assigment}
\begin{verbatim}
p = NULL;
\end{verbatim}
\begin{center}
\begin{figure}[h]
\centerline{
\includegraphics{../Figs/point8_2.eps}
}
\end{figure}
\end{center}
}
\newpage
{\samepage
\begin{verbatim}
p = &i;
\end{verbatim}
\begin{center}
\begin{figure}[h]
\centerline{
\includegraphics{../Figs/point8_3.eps}
}
\end{figure}
\end{center}
\begin{verbatim}
i = 5;
\end{verbatim}
\begin{center}
\begin{figure}[h]
\centerline{
\includegraphics{../Figs/point8_4.eps}
}
\end{figure}
\end{center}
}

\newpage
\section*{Dereferencing Pointers}
\begin{verbatim}
printf("%d\n", *p);/* Dereference p */
\end{verbatim}
This prints \verb^5^.
\begin{verbatim}
i = 17;
printf("%d\n", *p);
\end{verbatim}
This prints \verb^17^.

\newpage
\begin{verbatim}
*p = 10;
\end{verbatim}
\begin{center}
\begin{figure}[h]
\centerline{
\includegraphics{../Figs/point8_5.eps}
}
\end{figure}
\end{center}
\begin{verbatim}
printf("%d\n", i);
\end{verbatim}
This prints \verb^10^.

\newpage
\section*{Back to {\tt scanf()}}
Using:
\begin{verbatim}
scanf("%d", &i);
\end{verbatim}
is now the same as:
\begin{verbatim}
scanf("%d", p);
\end{verbatim}
provided that \verb^p = &i^.

In many ways the dereference operator \verb^*^ is
the inverse of the address operator \verb^&^.

\newpage
\section*{Equivalence}
\begin{verbatim}
float x, y, *p;

p = &x;
y = *p;
\end{verbatim}
\begin{center}
\begin{figure}[h]
\centerline{
\includegraphics{../Figs/point8_6.eps}
}
\end{figure}
\end{center}
What is this equivalent to ?
\newpage
Pointers may be assigned when both sides have the same type:
\begin{verbatim}
int *p;
p = 10;           /* Illegal */
p = (int *) 10;   /*  Legal  */
\end{verbatim}


\newpage
\section*{The Swap Function}
{\small
\begin{verbatim}
#include <stdio.h>

void swap(int *p, int *q);

int main(void)
{
   int   a = 3, b = 7;

   /* 3 7 printed */
   printf("%d %d\n", a, b);
   swap(&a, &b);
   /* 7 3 printed */
   printf("%d %d\n", a, b);
   return 0;
}

void swap(int *p, int *q)
{
   int   tmp;

   tmp = *p;
   *p = *q;
   *q = tmp;
}
\end{verbatim}
}

\newpage
\section*{Dissecting {\tt swap()}}
When the function is called:
\begin{center}
\begin{figure}[h]
\centerline{
\includegraphics{../Figs/point8_7.eps}
}
\end{figure}
\end{center}
\begin{verbatim}
tmp = *p;
*p = *q;
*q = tmp;
\end{verbatim}
\begin{center}
\begin{figure}[h]
\centerline{
\includegraphics{../Figs/point8_8.eps}
}
\end{figure}
\end{center}

\newpage
\section*{Storage Classes}
\begin{itemize}
\item {\bf auto}
\begin{verbatim}
auto int a, b, c;
auto float f;
\end{verbatim}
Because this is the default, it is seldom used.

\item {\bf extern}

Tells the compiler to look for the variable elsewhere,
possibly another file.

\item {\bf register}

Informs the compiler to place the variable in a high-speed
memory register if possible,\\ i.e.\ if there are enough such
registers available \& the hardware supports this.

\item {\bf static}

Allows local variables to maintain their values :
\begin{verbatim}
void f(void)
{

   static int cnt = 0;

   cnt++;
}
\end{verbatim}
\end{itemize}

\newpage
\section*{Type Qualifiers}

\begin{itemize}
\item {\bf const}
\begin{verbatim}
const int k = 3;
\end{verbatim}
Once \verb^k^ is initialised, it cannot be changed in any way.

\item {\bf volatile}
{\small
\begin{verbatim}
extern const volatile int real_time_clock;
\end{verbatim}
}
Very rarely used, this variable may be changed by the {\it hardware}
in some unspecified way.
\end{itemize}

\newpage
{\samepage
\begin{center}
{\Large Chapter Nine \\ Arrays \& Pointers}
\end{center}

\newpage
\section*{One-Dimensional Arrays}
\begin{verbatim}
#include <stdio.h>

#define   N   5

int main(void)
{
   /* allocate space a[0]...a[4] */
   int   a[N];
   int   i, sum = 0;

   /* fill array */
   for (i = 0; i < N; ++i)
      a[i] = 7 + i * i;
   /* print array */
   for (i = 0; i < N; ++i)
      printf("a[%d] = %d", i, a[i]);
   /* sum elements */
   for (i = 0; i < N; ++i)
      sum += a[i];
   /* print sum */
   printf("\nsum = %d\n", sum);
   return 0;
}
\end{verbatim}
}
\newpage
\begin{itemize}
\item One-Dimensional arrays are declared by a type
followed by an identifier with a bracketed constant expression:
\vspace{-1em}
\begin{verbatim}
float x[10];
int k[ARRAY_SIZE];
\end{verbatim}
\vspace{-1em}
The following, however, is not valid:
\vspace{-1em}
\begin{verbatim}
float y[i*2];
\end{verbatim}
\vspace{-1em}
\item Arrays are stored in contiguous memory, e.g.:
\vspace{-1em}
\begin{verbatim}
int a[5];
\end{verbatim}
\vspace{-1em}
\begin{center}
\begin{figure}[h]
\centerline{
\includegraphics{../Figs/array9_1.eps}
}
\end{figure}
\end{center}
\item Arrays are indexed {\bf 0} to {\bf n-1}.
\end{itemize}
\newpage
\section{Initialisation}
By default, arrays are uninitialised.
When they are declared, they may be assigned a value:
{\small
\begin{verbatim}
float x[7] = {-1.1,0.2,2.0,4.4,6.5,0.0,7.7};
\end{verbatim}
}
or,
{\small
\begin{verbatim}
float x[7] = {-1.1, 0.2};
\end{verbatim}
}
the elements 2 ... 6 are set to zero.

Also:
{\small
\begin{verbatim}
int a[] = {3, 8, 9, 1};
\end{verbatim}
}
is valid, the compiler assumes the array size to be \verb^4^.


\newpage
\section*{Using Arrays}
\begin{itemize}
\item Accessing an array out of bounds will not be identified by
the compiler. It may cause an error at run-time.
One frequent result is that an entirely unrelated variable
is altered.
\item \verb^a[5] = a[4] + 1;^
\item \verb^k[9]++;^
\item \verb^n[12+i] = 0;^
\end{itemize}

\newpage
{\samepage
\begin{verbatim}
/* Count lowercase letters */
#include <stdio.h>
#include <ctype.h>

int main(void)
{
   int   c, i, letter[26];

   /*  zero   */
   for (i = 0; i < 26; ++i)
      letter[i] = 0;
   /*  count  */
   while ((c = getchar())!=EOF)
      if (islower(c))
         ++letter[c - 'a'];
   /* results */
   for (i = 0; i < 26; ++i) {
      if (i % 5 == 0)
         printf("\n");
      printf("%c:%4d  ", 'a' + i,
              letter[i]);
   }
   printf("\n\n");
   return 0;
}
\end{verbatim}
}
\newpage
The results of running the code on
the handout of lectures 1 to 7:
\begin{verbatim}
a: 840  b: 212  c: 436  d: 409  e:1449
f: 313  g: 173  h: 392  i:1112  j:   9
k:  34  l: 470  m: 373  n: 952  o: 666
p: 285  q:  21  r: 743  s: 696  t:1196
u: 398  v: 157  w:  97  x:  56  y: 148
z:  43
\end{verbatim}
\newpage
{\samepage
\section*{Arrays are Pointers ?}
\vspace{-1em}
An array name by itself is simply an address.
For instance:
\begin{verbatim}
int a[5];
int *p;
\end{verbatim}
declares an array of \verb^5^ elements, and
\verb^a^ is the address of the start of the
array.
Assigning:
\vspace{-1em}
\begin{verbatim}
p = a;
\end{verbatim}
\vspace{-1em}
is completely valid and
the same as:
\vspace{-1em}
\begin{verbatim}
p = &a[0];
\end{verbatim}

\begin{center}
\begin{figure}[ht]
\centerline{
\includegraphics{../Figs/array9_2.eps}
}
\end{figure}
\end{center}
}
\newpage
{\samepage
To assign \verb^p^ to point to the next element,
we could use
\begin{verbatim}
p = a + 1;
\end{verbatim}
or
\begin{verbatim}
p = &a[1];
\end{verbatim}
\begin{itemize}
\item Notice that \verb^p = a + 1^ advances
the pointer {\bf 4} bytes and not 1 byte.
This is because an integer is 4 bytes long and
\verb^p^ is a pointer to an int.
\item we can use the pointer \verb^p^ is exactly
the same way as normal, i.e.:
\begin{verbatim}
*p = 5;
\end{verbatim}
\end{itemize}
}

\newpage
\section*{Summing an Array - 1}
\begin{verbatim}
#include <stdio.h>

int main(void)
{

   int a[] = {10, 12, 6, 7, 2};
   int i;
   int sum = 0;

   for(i=0; i<5; i++){
      sum += a[i];
   }
   printf("%d\n", sum);

   return 0;

}
\end{verbatim}

\newpage
\section*{Summing an Array - 2}
\begin{verbatim}
#include <stdio.h>

int main(void)
{

   int a[] = {10, 12, 6, 7, 2};
   int i;
   int sum = 0;

   for(i=0; i<5; i++){
      sum += *(a + i);
   }
   printf("%d\n", sum);

   return 0;

}
\end{verbatim}

\newpage
\section*{Summing an Array - 3}
\begin{verbatim}
#include <stdio.h>

int main(void)
{

   int a[] = {10, 12, 6, 7, 2};
   int i;
   int sum = 0;
   int *p;

   p = a;
   for(i=0; i<5; i++){
      sum += *p;
      p++;
   }
   printf("%d\n", sum);

   return 0;

}
\end{verbatim}
\newpage
\section*{Passing Arrays to Functions}
When an array is passed to a function, what
is actually passed is a pointer to the base address,
not a copy of the array itself.
\begin{verbatim}
#include <stdio.h>

void zero_array(int b[], int s);
void zero_array2(int *b, int s);

int main(void)
{

   int a[5]; /* Uninitialised */

   zero_array(a, 5);
   return 0;

}
\end{verbatim}
\newpage
\begin{verbatim}
void zero_array(int b[], int s)
{

   int i;
   for(i=0; i<s; i++)
      b[i] = 0;
}

void zero_array2(int *b, int s)
{

   int i;
   for(i=0; i<s; i++)
      *b++ = 0;
}
\end{verbatim}
To initialise the middle three elements we could have called:
\begin{verbatim}
zero_array(&a[1], 3);
\end{verbatim}

\newpage
\section*{The Bubblesort}
\begin{verbatim}
#include <stdio.h>

void bubble_sort(int b[], int s);

int main(void)
{

   int i;
   int a[] = {3, 4, 1, 2, 9, 0};

   bubble_sort(a, 6);

   for(i=0; i<6; i++){
      printf("%d ", a[i]);
   }
   printf("\n");

   return 0;

}
\end{verbatim}
\newpage
\begin{verbatim}
void bubble_sort(int b[], int s)
{

   int i, tmp;
   int changes;

   do{
      changes = 0;
      for(i=0; i<s-1; i++)
         if(b[i] > b[i+1]){
            tmp = b[i];
            b[i] = b[i+1];
            b[i+1] = tmp;
            changes++;
         }
   }while(changes);
}
\end{verbatim}
\newpage

During each pass, the array contains:
\begin{verbatim}
3 1 2 4 0 9
1 2 3 0 4 9
1 2 0 3 4 9
1 0 2 3 4 9
0 1 2 3 4 9
0 1 2 3 4 9
\end{verbatim}

\newpage
\section*{Two-Dimensional Arrays}
A 2D array is declared as follows:
\begin{verbatim}
#define ROWS 3
#define COLS 5
int a[ROWS][COLS];
\end{verbatim}
\begin{center}
\begin{tabular}{|l|l|l|l|l|l|} \hline
    &   col 1   & col 2 & col 3 & col 4 & col 5 \\ \hline
row 1   & a[0][0]   & a[0][1]   & a[0][2]   & a[0][3]   & a[0][4] \\
row 2   & a[1][0]   & a[1][1]   & a[1][2]   & a[1][3]   & a[1][4] \\
row 3   & a[2][0]   & a[2][1]   & a[2][2]   & a[2][3]   & a[2][4] \\ \hline
\end{tabular}
\end{center}
 2D array initialisation :
\begin{verbatim}
int a[2][3] = {1, 2, 3, 4, 5, 6};
int a[2][3] = {{1, 2, 3}, {4, 5, 6}};
int a[ ][3] = {{1, 2, 3}, {4, 5, 6}};
\end{verbatim}

\newpage
Although \verb^a^ is stored in a contiguous block of memory,
we may think of it as a 2D rectangle of data.
\begin{center}
\begin{figure}[h]
\centerline{
\includegraphics{../Figs/array9_3.eps}
}
\end{figure}
\end{center}
\verb^a[i][j]^ is equivalent to:\\
\verb^*(a[i] + j)^\\
\verb^(*(a + i))[j]^\\
\verb^*((*(a + i)) + j)^\\
\verb^*(&a[0][0] + 5*i + j)^


\newpage
\begin{verbatim}
#include <stdio.h>

/* number of rows */
#define   M   3
/* number of columns */
#define   N   4

int main(void)
{
   int   a[M][N], i, j, sum = 0;

   putchar('\n');
   /* fill array */
   for (i = 0; i < M; ++i)
      for (j = 0; j < N; ++j)
         a[i][j] = i + j;
   /* array values */
   for (i = 0; i < M; ++i){
      for (j = 0; j < N; ++j)
         printf("a[%d][%d] = %d ",
                 i, j, a[i][j]);
      printf("\n");
   }
   /* sum the array */
   for (i = 0; i < M; ++i)
      for (j = 0; j < N; ++j)
         sum += a[i][j];
   printf("\nsum = %d\n\n", sum);
   return 0;
}
\end{verbatim}

\newpage
\section*{Dynamic Memory}
In some cases the size of an array may not be known.
The size may be decided by the user, or by a computation.
There are two functions which provide the ability to
dynamically allocate memory:
\begin{verbatim}
void *calloc(num_els, el_size);
void *malloc(num_bytes);
\end{verbatim}
Both functions return pointers.
\verb^calloc()^ initialises its memory to
zero, whereas \verb^malloc()^ does not.
If \verb^NULL^ is returned, then the allocation
has failed.

The file \verb^stdlib.h^ contains definitions and prototypes
required to use the functions.

The function:\\
\verb^void free(void *ptr);^\\
frees the memory once it is no longer required.

\newpage
\begin{verbatim}
/* To allocate 256 bytes of memory */
#include <stdio.h>
#include <stdlib.h>

int main(void)
{

   int *p;

   p = (int *)malloc( 256 );

   if(p == NULL){
      printf("Allocation Failed...\n");
      exit(EXIT_FAILURE);
   }

   return(0);

}
\end{verbatim}


\newpage
\begin{center}
{\Large Chapter Ten \\ Strings \& Pointers}
\end{center}
\vspace{-0.5in}
\section*{Strings}
\begin{itemize}
\item Strings are 1D arrays of characters.
\item Any character in a string may be accessed as an array
element, or by dereferencing a pointer.
\item The important difference between strings and ordinary arrays
is the {\bf end-of-string sentinel} \verb^'\0'^ or null character.
\end{itemize}

\newpage
\begin{itemize}
\item The string "abc" has a {\it length} of 3, but its {\it size} is 4.
\item Note \verb^'a'^ and \verb^"a"^ are different. The first is a
character constant, the second is a string with 2 elements
\verb^'a'^ and \verb^'\0'^.
\end{itemize}

\newpage
\section*{Initialising Strings}
\begin{itemize}
\item \begin{verbatim}
char w[250];
w[0] = 'a';
w[1] = 'b';
w[2] = 'c';
w[3] = '\0';
\end{verbatim}
\item \begin{verbatim}
scanf("%s", w);
\end{verbatim}
Removes leading spaces, reads a string (terminated by a
space or \verb^EOF^). Adds a null character to the end
of the string.
\item \begin{verbatim}
char w[250] = {'a', 'b', 'c', '\0'};
\end{verbatim}
\end{itemize}

\newpage
{\samepage
\begin{itemize}
\item \begin{verbatim}
char w[250] = "abc";
\end{verbatim}
\item \begin{verbatim}
char *w = "abc";
\end{verbatim}
\end{itemize}
\begin{verbatim}

#include <stdio.h>
#include <ctype.h>

int main(void)
{
   char w1[100] = "test";
   char *w2 = "test";

   printf("%s -> ", w1);
   w1[0] = toupper(w1[0]);
   printf("%s\n", w1);

   printf("%s -> ", w2);
   /* Seg Faults */
   w2[0] = toupper(w2[0]);
   printf("%s\n", w2);

   return 0;
}
\end{verbatim}
}

\newpage
{\samepage
\section*{Repeated Characters}
{\small
\begin{verbatim}
#include <stdio.h>
#include <ctype.h>

int main(void)
{

   char s[100] =
      "The Quick Brown Fox Leaps " \
      "Over the Lazy Dog";
   short used[26] = {0};
   char c;
   int i = 0;

   while(s[i]){
      c = tolower(s[i]);
      if(islower(c)){
         used[c - 'a'] = 1;
      }
      i++;
   }

   for(i=0; i<26; i++)
      if(!used[i])
         printf("%c has not been used.\n",
                i+'a');

   return 0;

}
\end{verbatim}

Output:
\begin{verbatim}
j has not been used.
m has not been used
\end{verbatim}
}
}
\newpage
{\samepage
\section*{Pointers \& String Processing}
\begin{verbatim}
/* Character processing:
   change a line.        */

#include <stdio.h>

#define   MAXLINE   100

char   *change(char *s);
void   read_in(char s[]);

int main(void)
{
   char   line[MAXLINE];

   printf("\nWhat is your " \
          "favourite line? ");
   read_in(line);
   printf("\n%s\n\n%s\n\n",
    "Here it is after being changed:",
    change(line));
   return 0;
}
\end{verbatim}
}
\newpage
{\samepage
\begin{verbatim}
void read_in(char s[])
{
   int    c, i = 0;

   while ((c = getchar()) != EOF &&
           c != '\n')
      s[i++] = c;
   s[i] = '\0';
}

char *change(char *s)
{
   static char   new_string[MAXLINE];
   char          *p = new_string;

   *p++ = '\t';
   for ( ; *s != '\0'; ++s)
      if (*s == 'e')
       *p++ = 'E';
      else if (*s == ' ') {
       *p++ = '\n';
       *p++ = '\t';
      }
      else
       *p++ = *s;
   *p = '\0';
   return new_string;
}
\end{verbatim}
}
\newpage
{\samepage
\section*{Dissection}
\begin{verbatim}
What is your favourite line?
she sells sea shells

Here it is after being changed:

        shE
        sElls
        sEa
        shElls
\end{verbatim}
\begin{itemize}
\item Every \verb^e^ changes to \verb^E^, every space swapped
with a newline and tab.
\item In \verb^read_in()^ we assume less than \verb^MAXLINE^ characters
are entered. We could use an\\ \verb^assert()^ here.
\item Note the use of \verb^static^ in \verb^change()^.
\item \verb^*p++^ is equivalent to \verb^*(p++)^ and {\bf not}
\verb^(*p)++^.
\end{itemize}
}
\newpage
\section*{String Handling Functions}
In \verb^#include <string.h>^ :
{\small
\begin{verbatim}
char *strcat(char *dst, const char *src);
int strcmp(const char *s1, const char *s2);
char *strcpy(char *dst, const char *src);
unsigned strlen(const char *s);
\end{verbatim}
}
\begin{itemize}
\item \verb^strcat()^ appends a copy of string \verb^src^,
including  the  terminating null character,
to  the  end  of  string  \verb^dst^.
\item \verb^strcmp()^ compares two strings byte-by-byte, according to the
     ordering  of  your  machine's  character  set.  The function
     returns an integer greater than, equal to, or less  than  0,
     if the string pointed to by \verb^s1^ is greater than, equal to, or
     less than the string pointed to by \verb^s2^ respectively.
\item \verb^strcpy()^ copies string \verb^src^ to \verb^dst^
including the  terminating null  character,
stopping after the null character has been copied.
\item \verb^strlen()^ returns the number of bytes in \verb^s^,
not including the terminating null character.
\end{itemize}

\newpage
\section*{The Function {\tt strlen()}}
One way to write the function \verb^strlen()^
\begin{verbatim}
unsigned strlen(const char *s)
{

   register int n = 0;

   for(; *s != '\0'; ++s)
      ++n;
   return n;
}
\end{verbatim}

\newpage
\begin{center}
{\Large Chapter Twelve\\ Structures}
\end{center}
\vspace{-1.0in}
\section*{Declaring Structures}
\begin{itemize}
\item A structure type allows the programmer to aggregate components
into a single, named variable.
\item Each component has individually named members.
\item \begin{verbatim}
struct card {
   int pips;
   char suit;
};
\end{verbatim}
\item \verb^struct^ is a keyword, \verb^card^ is the structure
tag name, and \verb^pips^ and \verb^suit^ are members of the structure.
\end{itemize}

\newpage
\begin{itemize}
\item A statement of the form :\\
\verb^struct card c1, c2;^\\
actually creates storage for identifiers
\item A member is accessed using the member operator ``.''
\item
\begin{verbatim}
c1.pips = 5;
c1.suit = 'd';
c2.pips = 12;
c2.suit = 's';
\end{verbatim}
\item The member name must be unique within the same structure.
\end{itemize}
\newpage
\begin{itemize}
\item We can declare the structure and variables in one statement:
\begin{verbatim}
struct card {
   int pips;
   char suit;
} c1, c2;
\end{verbatim}
\item In the above, \verb^card^ is optional.
\item Arrays of structures are possible, i.e.:
\begin{verbatim}
struct card pack[52];
\end{verbatim}
\end{itemize}

\newpage
{\samepage
{\small
\begin{verbatim}
#include <stdio.h>
#include <ctype.h>

struct student {
   char *surname;
   int id;
   char grade;
};

int failures(struct student j[], int n);

int main(void)
{
   struct student class[] = {
      {"Bloggs",    95112174, 'c'},
      {"Doobeedoo", 96162578, 'b'},
      {"Campbell",  96112103, 'f'},
      {"Johnson",   96185617, 'a'}
   };
   printf("Number of fails : %d\n",
          failures(class, 4));
   return 0;
}

int failures(struct student j[], int n)
{

   int i, cnt = 0;

   for(i=0; i<n; i++)
      cnt += (tolower(j[i].grade) == 'f');
   return cnt;
}
\end{verbatim}
}}
\newpage
\section*{Structures \& Pointers}
\begin{itemize}
\item \verb^struct student *p;^\\
declares a pointer to a structure.
\item Point it at something sensible:\\
\verb^p = &c1;^
\item Now we access its members using the ``\verb^->^''
operator.
\item \verb^p->id = 96123040;^
\item The deference, followed by the member access, could also be written as: \verb^(*p).id = 96123949;^
\end{itemize}

\newpage
{\samepage
{\small
\begin{verbatim}
#include <stdio.h>
#include <ctype.h>

struct student {
   char *surname;
   int id;
   char grade;
};

int failures(struct student *j, int n);

int main(void)
{
   struct student class[] = {
      {"Bloggs",    95112174, 'c'},
      {"Doobeedoo", 96162578, 'b'},
      {"Campbell",  96112103, 'f'},
      {"Johnson",   96185617, 'a'}
   };

   printf("Number of fails : %d\n",
          failures(class, 4));
   return 0;
}

int failures(struct student *j, int n)
{
   int i, cnt = 0;
   for(i=0; i<n; i++){
      cnt += (tolower(j->grade) == 'f');
      j++;
   }
   return cnt;
}
\end{verbatim}
}}
\newpage
{\samepage
{\small
\begin{verbatim}
/* Nested Structures */
#include <stdio.h>

struct date {
   short day;
   short month;
   short year;
};

struct person {
   char name[25];
   struct date date;
};

void print_person_copy(struct person p);
void print_person_point(struct person *p);

int main(void)
{

   struct person k;

   printf("Enter your surname : ");
   scanf("%s", k.name);
   printf("Enter your Birthday: ");
   scanf("%hd/%hd/%hd", &k.date.day,
         &k.date.month, &k.date.year);

   print_person_copy(k);
   print_person_point(&k);

   return 0;
}
\end{verbatim}
}}
\newpage
{\small
\begin{verbatim}

void print_person_copy(struct person p)
{

   printf("Name \"%s\", Born " \
          "%02d/%02d/%d\n",
      p.name, p.date.day,
      p.date.month, p.date.year);

}

void print_person_point(struct person *p)
{

   printf("Name \"%s\", Born " \
          "%02hd/%02hd/%hd\n",
      p->name, p->date.day,
      p->date.month, p->date.year);

}
\end{verbatim}
}
\begin{verbatim}
Enter your surname : Campbell
Enter your Birthday: 8/12/68
Name "Campbell", Born 08/12/68
Name "Campbell", Born 08/12/68
\end{verbatim}

\newpage
\section*{Self-Referential Structures}
\begin{verbatim}
struct list {
   int data;
   struct list *next;
};
\end{verbatim}
\begin{itemize}
\item The pointer variable \verb^next^ is called a {\bf link}.
\item \begin{verbatim}
struct list a, b, c;
a.data = 1;
b.data = 2;
c.data = 3;
a.next = b.next = c.next = NULL;
\end{verbatim}
\begin{center}
\begin{figure}[h]
\centerline{
\includegraphics{../Figs/link1.eps}
}
\end{figure}
\end{center}
\end{itemize}
\newpage
\begin{itemize}
\item \begin{verbatim}
a.next = &b;
b.next = &c;
\end{verbatim}
\begin{center}
\begin{figure}[h]
\centerline{
\includegraphics{../Figs/link2.eps}
}
\end{figure}
\end{center}
\item \begin{verbatim}
/* has value 2 */
a.next -> data;
/* has value 3 */
b.next -> data;
/* has value 3 */
a.next -> next -> data;
\end{verbatim}
\end{itemize}

\newpage
\section*{Dynamic List Creation}
\begin{itemize}
\item We may need to dynamically create objects in a linked
list, using \verb^malloc()^.
\item \verb^malloc(sizeof(list));^ returns a pointer
to a new, free block of memory.
\item Need to be able to Add/Delete/Count/Insert elements.
\end{itemize}

\newpage
{\samepage
{\small
\begin{verbatim}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BIGGESTNAME 50

struct llist {
   char word[BIGGESTNAME];
   struct llist *next;
};

int main(void)
{
   struct llist *head, *cp;

   printf("Enter a list of words.\n");
   cp = head = calloc(1, sizeof(struct llist));
   while(scanf("%s", cp->word)==1){
      cp->next = calloc(1, sizeof(struct llist));
      cp = cp->next;
   }

   cp = head;
   printf("The words were :\n");
   while(cp->next != NULL){
      printf("%s\n", cp->word);
      cp = cp->next;
   };
   return 0;
}
\end{verbatim}
}}

\newpage
\begin{center}
{\Large Chapter Thirteen\\ File Handling}
\end{center}
\section*{File Properties}
Files have many important properties:
\begin{itemize}
\item They have a name.
\item Until a file is opened nothing can be done with it.
\item After use a file must be closed.
\item Files may be read, written or appended.
\item Conceptually a file may be thought of as a stream of characters.
\end{itemize}

\newpage
\section*{Accessing Files}
\vspace{-0.75em}
\begin{verbatim}
#include <stdio.h>

int main(void)
{

   int sum = 0, val;
   FILE *ifp, *ofp;

   /* Read a File */
   ifp = fopen("my_file", "r");
   /* Write to a File */
   ofp = fopen("outfile", "w");

     .
     .
     .

   fclose(ifp);
   fclose(ofp);
}
\end{verbatim}
\vspace{-0.75em}
\newpage
\section*{Opening Files}
\vspace{-0.75em}
{\small
\begin{verbatim}
FILE *fopen(char *filename, char *modes);
\end{verbatim}
}
\vspace{-0.75em}
The mode for file opening is a {\it string}, and can
take the following options:
\begin{center}
\begin{tabular}{|l|l|}\hline
``r''  & open text file for reading \\ \hline
``w''  & open text file for writing \\ \hline
``a''  & open text file for appending\\ \hline
``rb'' & open binary file for reading \\ \hline
``wb''  & open binary file for writing\\ \hline
``ab''  & open binary file for appending\\ \hline
\end{tabular}
\end{center}
If the file cannot be found, or if it is not readable,
then the function returns \verb^NULL^.
\vspace{-0.75em}
\begin{verbatim}
fp = fopen("filedoof", "r");
if(fp == NULL){
   exit(EXIT_FAILURE);
}
\end{verbatim}

\newpage
\section*{Getting \& Putting Characters}
The functions \verb^fgetc()^ and \verb^fputc()^ are
similar to \verb^getchar()^ and \verb^putchar()^, but
additionally take a file pointer as an argument.
\vspace{-0.75em}
\begin{verbatim}
int fgetc(FILE *stream);
int fputc(int c, FILE *stream);
\end{verbatim}

\newpage
{\samepage
\vspace*{-1in}
\begin{small}
\begin{verbatim}
/* Number the lines of a file */
#include <stdio.h>

int main(void)
{

   FILE *fp;
   char fname[128];
   char str[500];
   int i, c, line;

   printf("What file would you like to see ? ");
   scanf("%s", fname);
   if((fp = fopen(fname, "r")) == NULL){
      printf("Cannot open file\n");
      exit(EXIT_FAILURE);
   }
   line = 1;
   do{
      i = 0;
      do{
         c = (str[i++] = fgetc(fp));
      }while(c != EOF && c != '\n');
      str[i] = '\0';
      if(c != EOF){
         printf("%5d %s", line, str);
         line++;
      }
   }while(c != EOF);
   fclose(fp);

   return 0;
}
\end{verbatim}
\end{small}
}

\newpage
{\samepage
\vspace*{-1in}
\begin{small}
\begin{verbatim}
/* Copying Files */
#include <stdio.h>
#include <stdlib.h>

#define MAXFILENAME 128

int main(void)
{

   FILE *ifp, *ofp;
   char inpname[MAXFILENAME];
   char oupname[MAXFILENAME];
   int i;

   printf("Enter two filenames : ");
   if(scanf("%s %s", inpname, oupname) != 2){
      printf("Failed to scan two filenames.");
      exit(EXIT_FAILURE);
   }
   ifp = fopen(inpname, "rb");
   ofp = fopen(oupname, "wb");
   if(ifp == NULL || ofp == NULL){
      printf("Failed to open two filenames.");
      exit(EXIT_FAILURE);
   }
   while((i = fgetc(ifp)) != EOF){
      fputc(i, ofp);
   };

   fclose(ifp);
   fclose(ofp);

   return 0;

}
\end{verbatim}
\end{small}
}
\newpage
\section*{Reading / Writing Data Blocks}
The functions \verb^fread()^ and \verb^fwrite()^ allow
blocks of information to be read and written using files.
\begin{small}
\begin{verbatim}
fread(void *ptr, size, num_items, stream);
fwrite(void *ptr, size, num_items, stream);
\end{verbatim}
\end{small}
\vspace{-0.25em}
They return an unsigned integer, the number of elements correctly
read or written.

\newpage
{\samepage
\vspace*{-1in}
\begin{small}
\begin{verbatim}
#include <stdio.h>
#include <stdlib.h>

struct examp {
   int h[100];
   double k;
   char c;
};
typedef struct examp examp;

int main(void)
{

   FILE *fp;
   examp e;
   printf("%d\n", sizeof(double));
   if((fp = fopen("doof", "rb")) == NULL){
      printf("Cannot read file\n");
      exit(EXIT_FAILURE);
   }
   /* Should check return from fread */
   fread(&e, sizeof(struct examp), 1, fp);
   printf("k = %f\n", e.k);
   fclose(fp);
    .
    .
    .
   if((fp = fopen("doof", "wb")) == NULL){
      printf("Cannot write file\n");
      exit(EXIT_FAILURE);
   }
   /* Should check return from fwrite */
   fwrite(&e, sizeof(struct examp), 1, fp);
   fclose(fp);
   return 0;
}
\end{verbatim}
\end{small}
}
\newpage
\section*{Printing and Scanning Files}
The functions:
{\small
\begin{verbatim}
int fprintf(FILE *stream, format, other args);
int fscanf(FILE *stream, format, other args);
\end{verbatim}
}
act almost the same as their \verb^printf()^ and \verb^scanf()^
counterparts, except that input is from file rather than keyboard.

\newpage
\begin{small}
\begin{verbatim}
#include <stdio.h>
#include <stdlib.h>

int main(void)
{

   FILE *fp;

   if((fp = fopen("file.txt", "w")) == NULL){
      printf("Cannot open file\n");
      exit(EXIT_FAILURE);
   }
   fprintf(fp, "Hello World\n");
   fclose(fp);

   return 0;
}
\end{verbatim}
\end{small}
Creates a file called \verb^file.txt^ with the
string \verb^Hello World^ in it.

\newpage
\section*{Stdout and Stderr}
On Unix systems, there are three pre-defined streams,
\verb^stdin^, \verb^stdout^ and \verb^stderr^. Since
\verb^stdin^ is the standard input stream, \verb^scanf()^ is
simply as special case of \verb^fscanf()^.
\begin{verbatim}
scanf("%d", &i);
fscanf(stdin, "%d", &i);
\end{verbatim}
Likewise, \verb^printf()^ is a special case of \verb^fprintf()^:
\begin{verbatim}
printf("%s %d", "The number is", i);
fprintf(stdout, "%s %d",
        "The number is", i);
\end{verbatim}
For printing error messages use:
\begin{verbatim}
fprintf(stderr, "Cannot open file %s",
        fname);
exit(EXIT_FAILURE);
\end{verbatim}
Even if \verb^stdout^ is being re-directed to a file, this
message will appear on the screen.

\newpage
\section*{Advanced {\tt scanf()}}
It is possible to specify a {\it scan set} when using\\
\verb^scanf()^ to input a string. For instance:
\vspace{-0.75em}
\begin{verbatim}
scanf("%[abc]s", str);
\end{verbatim}
\vspace{-0.75em}
allows you to read in a string containing the characters
\verb^a^,
\verb^b^ or
\verb^c^.
The string is terminated by any other character, so:
\vspace{-0.75em}
\begin{verbatim}
Please type a string : abacus
I scanned : abac
\end{verbatim}
\vspace{-0.75em}
A circumflex is used to specify only characters {\it not} in
the scan set.
\vspace{-0.75em}
\begin{verbatim}
scanf("%[^k]s", str);
\end{verbatim}
\vspace{-0.75em}
leads to every possible character other than \verb^'k'^ being
used in the scan set.
\vspace{-0.75em}
\begin{verbatim}
Please type a string : I Am Crackers
I scanned : I Am Crac
\end{verbatim}
\vspace{-0.75em}
\newpage
\section*{The {\tt sprintf()} Function}
This is very similar to the function \verb^printf()^, except
that the output is stored in a string rather than written
to the output.
It is defined as:
\vspace{-0.75em}
{\small
\begin{verbatim}
int sprintf(string, control-arg, other args);
\end{verbatim}
}
\vspace{-0.75em}
For example:
\vspace{-0.75em}
\begin{verbatim}
   int i = 7;
   float f = 17.041;
   char str[100];
   sprintf(str, "%d %f", i, f);
   printf("%s\n", str);

Outputs : 7 17.041000
\end{verbatim}
\vspace{-0.75em}
This is useful if you need to create a string for passing
to another function for further processing.

\newpage
\section*{The {\tt sscanf()} Function}
This is similar to the \verb^scanf()^ function, except
that the input comes from a string rather than from the keyboard.
It is defined as:
\vspace{-0.75em}
{\small
\begin{verbatim}
int sscanf(char *s, char *format, other args);
\end{verbatim}
}
\vspace{-0.75em}
For example:
\vspace{-0.75em}
\begin{small}
\begin{verbatim}
#include <stdio.h>
#include <stdlib.h>

#define STRLN 100

int main(void)
{

   char str[STRLN];
   int i;
   fgets(str, STRLN, stdin);
   while(sscanf(str, "%d", &i) != 1){
      printf("Cannot scan string !\n");
      fgets(str, STRLN, stdin);
   }
   printf("The number was %d.", i);

   return 0;
}
\end{verbatim}
\vspace{-0.75em}
\end{small}

\newpage
{\samepage
\section*{IO Summary}
\vspace{-1.5em}
{\large \bf Keyboard\\}
\vspace{-1.75em}
\begin{verbatim}
scanf(), getchar()
\end{verbatim}
{\large \bf Screen\\}
\vspace{-1.5em}
\begin{verbatim}
printf(), putchar()
\end{verbatim}
{\large \bf Output to File\\}
\vspace{-1.5em}
\begin{verbatim}
fprintf(), fputc(), fwrite()
\end{verbatim}
{\large \bf Input from File\\}
\vspace{-1.5em}
\begin{verbatim}
fscanf(), fgetc(), fread()
\end{verbatim}
{\large \bf Output to String}
\vspace*{-1.5em}
\begin{verbatim}
sprintf()
\end{verbatim}
{\large \bf Input from String}
\vspace*{-1.5em}
\begin{verbatim}
sscanf()
\end{verbatim}
}



\newpage
\section*{Common Errors}
\begin{itemize}
\item \verb^fopen("myfile", 'r');^
\item \verb^double d; scanf("%f", &d);^
\item Not using \verb^fclose()^
\item Every time \verb^sscanf()^ is called, scanning begins
at the start of the string, unlike \verb^fscanf()^ where
a record is kept of how far through the file we are.
\end{itemize}

\end{document}
